# -*- coding: utf-8 -*-
"""
Created on Tue Mar 03 15:08:46 2020

@author: joshm
"""
import random

class ExploreExploitPlayer(Player):
    def __init__(self, rootSystem, window, genes, gene_length):
        super().__init__(rootSystem, window)
        self.rootSystem.tipTex=TEXTURES[3]
        self.genestrand = genes
        self.gene_length = gene_length
        self.traits = []
        self.readGenes()
    
    def readGenes(self):
        # finds the count of alleles in a gene
        #print(len(self.genestrand))
        #print(self.gene_length)
        for i in range(int((len(self.genestrand))/self.gene_length)):
            count = 0
            for j in range(self.gene_length):
                if self.genestrand[j] == '1':
                    count += 1
            self.traits.append(count)
        
    def determineLikelihood(self):
        # runs the probabilities based on allele counts in genes
        probExplore = random.randint(0, self.traits[0])
        probExploit = random.randint(0, self.traits[1])
        
        if probExplore > probExploit:
            return 0
        else:
            return 1
        
    def takeTurn(self):
        #determine if in explore or exploit mode
        moveToMake = self.determineLikelihood()
        if moveToMake == 0:
            self._exploitMove()
        else:
            self._exploreMove()
        #call the correct play turn based on the information from the string
        
    def _exploitMove(self):
        #print("exploit")
        moves = self.rootSystem.legalMoves()                  
         
        target = None
        oldtarget = None
        origin = None
        tdist = 0
        olddist = 0
        oldorigin = None
        fork = True
         #find the closest and second closest nutrients
        for b in self.rootSystem.world.world.keys():
            if self.rootSystem.world.world[b] == TEXTURES[4]:
                for t in self.rootSystem.tips.keys():
                    dist = abs(t[0]-b[0])+abs(t[1]-b[1])+abs(t[2]-b[2])
                    if dist >= tdist and self.rootSystem.tips[t]:
                        tdist = dist
                        if b != target:
                            olddist = tdist
                            oldtarget = target
                            oldorigin = origin
                        target = b
                        origin = t
 
        newmoves = []
        if target:
            for m in moves:
                if abs(m[1][0]-target[0])+abs(m[1][1]-target[1])+abs(m[1][2]-target[2]) > tdist:
                    newmoves.append(m)
             #if there is a second closest
            if oldtarget:
                newdist = abs(target[0]-oldtarget[0])+abs(target[1]-oldtarget[1])+abs(target[2]-oldtarget[2])
                 #if the second closest nutrient is best reached from a tip other than origin, don't fork
                if oldorigin != origin:
                    fork = False
                 #if it's easier to reach the second closest nutrient from the target than from the tip that will approach the target, do not fork
                if fork and (newdist-olddist < FORK_COST/ROOT_COST):
                    fork = False
            else:
                 #if there is only 1 nutrient known, do not fork
                fork = False
 
         #accept sideways or backwards moves when moving toward the target is not possible
        margin = 0
        while len(newmoves)==0 and margin< 2 and self.rootSystem.energy>0:
            margin += 1
            if target:
                for m in moves:
                    if abs(m[1][0]-target[0])+abs(m[1][1]-target[1])+abs(m[1][2]-target[2]) < tdist+margin:
                        newmoves.append(m)
 
 
        if len(newmoves)==0: return
             
        move = random.choice(newmoves)
        self.rootSystem.addToTip(move[0],move[1], fork)

        
    def _exploreMove(self):
        #print("explore")
        moves = self.rootSystem.legalMoves()                  
         
        target = None
        oldtarget = None
        origin = None
        tdist = 99999
        olddist = 99999
        oldorigin = None
        fork = True
         #find the closest and second closest nutrients
        for b in self.rootSystem.world.world.keys():
            if self.rootSystem.world.world[b] == TEXTURES[4]:
                for t in self.rootSystem.tips.keys():
                    dist = abs(t[0]-b[0])+abs(t[1]-b[1])+abs(t[2]-b[2])
                    if dist <= tdist and self.rootSystem.tips[t]:
                        tdist = dist
                        if b != target:
                            olddist = tdist
                            oldtarget = target
                            oldorigin = origin
                        target = b
                        origin = t
 
        newmoves = []
        if target:
            for m in moves:
                if abs(m[1][0]-target[0])+abs(m[1][1]-target[1])+abs(m[1][2]-target[2]) < tdist:
                    newmoves.append(m)
             #if there is a second closest
            if oldtarget:
                newdist = abs(target[0]-oldtarget[0])+abs(target[1]-oldtarget[1])+abs(target[2]-oldtarget[2])
                 #if the second closest nutrient is best reached from a tip other than origin, don't fork
                if oldorigin != origin:
                    fork = False
                 #if it's easier to reach the second closest nutrient from the target than from the tip that will approach the target, do not fork
                if fork and (newdist-olddist < FORK_COST/ROOT_COST):
                    fork = False
            else:
                 #if there is only 1 nutrient known, do not fork
                fork = False
 
         #accept sideways or backwards moves when moving toward the target is not possible
        margin = 0
        while len(newmoves)==0 and margin< 2 and self.rootSystem.energy>0:
            margin += 1
            if target:
                for m in moves:
                    if abs(m[1][0]-target[0])+abs(m[1][1]-target[1])+abs(m[1][2]-target[2]) < tdist+margin:
                        newmoves.append(m)
 
 
        if len(newmoves)==0: return
             
        move = random.choice(newmoves)
        self.rootSystem.addToTip(move[0],move[1], fork)